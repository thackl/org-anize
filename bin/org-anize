#!/bin/bash

# Author: Thomas Hackl - thackl@lim4.de
# Version: v1.0.0

# find script dir
[ -h $0 ] && SCRIPT=$(readlink "$0") || SCRIPT="$0";
SCRIPT_DIR=$(dirname $SCRIPT);

# read config
if [ -f $SCRIPT_DIR/org-anize-rc ]; then
    . $SCRIPT_DIR/org-anize-rc
fi


##----------------------------------------------------------------------------##
# find - sets up the PATH cache for all of the other functions
org-find(){
    ORG_PATH="$ORG_PATH_FAV" && [ $OPT_ALL ] && ORG_PATH="$ORG_PATH $ORG_PATH_MORE"
    ORG_PATH="${ORG_PATH//[:$'\n']/ }"
    ORG_PATH=$(eval echo $ORG_PATH)
    echo $ORG_PATH
    ORGS=$(
        find $ORG_PATH -maxdepth 3 -iname "*"$PRO"*-project.org" -a ! -name ".*" |
            xargs -n1 readlink -f 2>/dev/null |
            sort | uniq
        );
    PROS=($(for dir in $ORGS; do dir=$(dirname $dir); echo ${dir%/org}; done;))
    SUPS=($(for pro in ${PROS[@]}; do sup=$(basename $(dirname $pro)); echo ${sup}; done;))
    [ -z "$PROS" ] && { echo "No *-project.org file matching '"$PRO"' found" >&2; exit 1; }
}

##----------------------------------------------------------------------------##
# list projects
org-list(){

    org-find;

    if [ -n "$PROS" ]; then
	printf "%-30s %-15s %s\n" Project Super Path
        printf -- '=%.0s' {1..80}; echo;
        for ((i=0;i<${#PROS[@]};++i)); do
	    printf "%-30s %-15s %s\n" $(basename ${PROS[i]}) ${SUPS[i]} ${PROS[i]};
	done;
    else
	echo "No *-project.org file matching '"$PRO"' found" 1>&2
    fi;
}

##----------------------------------------------------------------------------##
# edit
org-edit(){

    org-find;

    TARGET=$1; # by default, open *-project-org file

    if [ 0 -lt ${#PROS[@]} ]; then
	if [ $ORG_MAX_OPEN -lt ${#PROS[@]} ]; then
	    echo -e "Matching too many projects!" >&2;
	else
	    if [ -z $TARGET ]; then
		for org in $ORGS; do echo "editing $org"; done;
		$ORG_EDITOR $ORGS &
	    fi;
	fi;
    fi;
}

##----------------------------------------------------------------------------##
# browse
org-browse(){

    org-find;

    if [ 0 -lt ${#PROS[@]} ]; then
	if [ $ORG_MAX_OPEN -lt ${#PROS[@]} ]; then
	    echo "Matching too many projects!" >&2
	else
	    for pro in $PROS; do
                echo "opening $pro in $ORG_FILEMANAGER"
		$ORG_FILEMANAGER "$pro" &
	    done;
	fi;
    fi;
}

##----------------------------------------------------------------------------##
# return single project directory
org-dir(){

    org-find;

    if [ 0 -lt ${#PROS[@]} ]; then
	if [ 1 -lt ${#PROS[@]} ]; then
	    echo "Matching too many projects" 1>&2; exit;
	else
	    for pro in $PROS; do
		echo $pro;
	    done;
	fi;
    fi;
}

##----------------------------------------------------------------------------##
# init
org-init(){
    [ -z "$PRO" ] && { echo 'project name required'; exit 1; }
    PRO_DATE=$(date +"%D")
    mkdir -p $PRO;

    for subdir in ${ORG_PRO_DIRS//:/ }; do
        mkdir -p "$PRO/$subdir";
    done

    PRO_FILE=$PRO/$PRO$ORG_PRO_SUF; # create *-project.org at top-level
    if [ ! -e $PRO_FILE ]; then
        echo "$ORG_PRO_TPL" | while read -r line ; do
            while [[ "$line" =~ (\$\{[a-zA-Z_][a-zA-Z_0-9]*\}) ]] ; do
                LHS=${BASH_REMATCH[1]}
                RHS="$(eval echo "\"$LHS\"")"
                line=${line//$LHS/$RHS}
            done
            echo "$line" >> $PRO_FILE
        done
    fi;

    echo "Created project [$PRO]";
}

##----------------------------------------------------------------------------##
# init workpack
org-workpack(){
    WPK=$PRO
    [ -z "$WPK" ] && { echo 'workpack name required'; exit 1; }
    get-project

    WPK_DATE=$(date +"%D")
    mkdir -p $WPK;

    for subdir in ${ORG_WPK_DIRS//:/ }; do
        mkdir -p "$WPK/$subdir";
    done

    WPK_FILE=$WPK/$WPK$ORG_WPK_SUF; # create *-workpack.org at top-level
    if [ ! -e $WPK_FILE ]; then
        echo "$ORG_WPK_TPL" | while read -r line ; do
            while [[ "$line" =~ (\$\{[a-zA-Z_][a-zA-Z_0-9]*\}) ]] ; do
                LHS=${BASH_REMATCH[1]}
                RHS="$(eval echo "\"$LHS\"")"
                line=${line//$LHS/$RHS}
            done
            echo "$line" >> $WPK_FILE
        done
    fi;

    echo "Created workpack [$WPK] in project [$PRO]";
}

# check if current dir is project
get-project(){
    ls *$ORG_PRO_SUF &>/dev/null || { echo "not inside a project"; exit 1; }
    PROS=( *$ORG_PRO_SUF )
    PRO=$(basename ${PROS[0]} $ORG_PRO_SUF)
}


##----------------------------------------------------------------------------##
# aliases - convenient for placing them in bashrc...
org-alias(){
    echo "## org-anize
alias oi='org-anize init'     # create new org-project
alias of='org-anize list'     # find and list favorite projects
alias ol='org-anize list -a'  # find and list all projects
alias ob='org-anize browse'   # open projects root dir
alias oe='org-anize edit'     # edit projects org file
od(){cd \$(org-anize dir \$@)}  # change to project dir (needs to be function)"
}

##----------------------------------------------------------------------------##
org-help(){
    echo 'Usage: org-anize <command> [options] [project/pattern]

  init    initialize new project with default directory structure at <project>
  list    find and list available projects
  chdir   change into <project-pattern> directory
  edit    edit <project-pattern>-project.org file with default editor ['$ORG_EDITOR']
  browse  open <project-pattern> directory in default file manager ['$ORG_FILEMANAGER']
  alias   print suggested shell aliases

   -a     work with all projects, default is to work only with favorites
   -V     show script version
   -h     show this help
'
}


##----------------------------------------------------------------------------##

# Require args
[ $# -eq 0 ] && { org-help && exit 0; }

# Execute getopt
ARGS=`getopt --name "SCRIPT" \
    --options "ahV" \
    -- "$@"`
[ $? -ne 0 ] && exit 1; # Exit if bad args
eval set -- "$ARGS" # A little magic

# Now go through all the options
while true; do
    case "$1" in
        # -c|--code-projects)
        #     [ ! -n "$2" ] && (echo "$1: value required" 1>&2 && exit 1);
        #     CODE=$2
        #     shift 2;;
        -a) OPT_ALL=1; shift;;
	-h) org-help && exit 0;;
        -V) grep -m1 'Version' "$0" | sed 's/.*Version.\s*//'; exit 0;;
        --) shift; break;;
        *) echo "$1: Unknown option" 1>&2 && exit 1;;
  esac
done

CMD=${1:-"help"}
PRO=$2;

shift;
shift;

org-$CMD $@;
