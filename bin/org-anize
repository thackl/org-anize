#!/bin/bash

# Author: Thomas Hackl - thackl@lim4.de
# Version: v1.0.0

# find script dir
[ -h $0 ] && SCRIPT=$(readlink "$0") || SCRIPT="$0";
SCRIPT_DIR=$(dirname $SCRIPT);

# read config
if [ -f $SCRIPT_DIR/org-anize-rc ]; then
    . $SCRIPT_DIR/org-anize-rc
fi


##----------------------------------------------------------------------------##
# find - sets up the PATH cache for all of the other functions
org-find(){
    ORG_PATH="$ORG_PATH_FAV" && [ $OPT_ALL ] && ORG_PATH="$ORG_PATH $ORG_PATH_MORE"
    ORG_PATH="${ORG_PATH//[:$'\n']/ }"
    ORG_PATH=$(eval echo $ORG_PATH)
    ORG_LEVEL=project
    ORGS=$(
        find $ORG_PATH -maxdepth 3 -iname "*"$PRO"*"$ORG_PRO_SUF -a ! -name ".*" |
            xargs -n1 readlink -f 2>/dev/null |
            sort | uniq
        );
    PROS=($(for dir in $ORGS; do dir=$(dirname $dir); echo ${dir%/org}; done;))
    check-pro-min;

    if [ -n "$WPK" ]; then
        ORG_LEVEL=workpack
        ORGS=$(find $PROS -maxdepth 2 -name "*"$WPK"*"$ORG_WPK_SUF -a ! -name ".*" | sort)
        PROS=($(for dir in $ORGS; do dirname $dir; done;))
        check-pro-min;
    fi;

}

check-pro-max(){
    if [ $ORG_MAX_OPEN -lt ${#PROS[@]} ]; then
        echo -e "Matching too many ${ORG_LEVEL}s!" >&2;
        exit 1;
    fi;
}

check-pro-min(){
    MATCH=$PRO
    [ $ORG_LEVEL == "workpack" ] && MATCH=$WPK
    if [ -z "$PROS" ]; then
        echo "No $ORG_LEVEL.org file matching '"$MATCH"' found" >&2;
        exit 1;
    fi;
}

##----------------------------------------------------------------------------##
# list projects
org-list(){

    org-find;

    if [ $ORG_LEVEL == workpack ]; then
	printf "%-30s %-15s %s\n" Workpack Project Path
    else
	printf "%-30s %-15s %s\n" Project Super Path
    fi;

    printf -- '=%.0s' {1..80}; echo;
    for ((i=0;i<${#PROS[@]};++i)); do
        I=${PROS[i]}
	printf "%-30s %-15s %s\n" $(name $I) $(sup-name $I) $(path $I);
    done;
}

name(){ echo $(basename $1); }
sup-name(){ echo $(basename $(dirname $1)); }
path(){ echo ${1/$HOME\//'~'/}; }



##----------------------------------------------------------------------------##
# edit
org-edit(){

    org-find;
    check-pro-max;

    for org in $ORGS; do
        echo $org
        echo -e "editing $ORG_LEVEL "$(sup-name $org);
    done;
    $ORG_EDITOR $ORGS &
}

##----------------------------------------------------------------------------##
# browse
org-browse(){

    org-find;
    check-pro-max;

    for pro in $PROS; do
        echo "opening $pro in $ORG_FILEMANAGER"
	$ORG_FILEMANAGER "$pro" &
    done;
}

##----------------------------------------------------------------------------##
# return single project directory
org-dir(){

    org-find;
    check-pro-max;

    for pro in $PROS; do
	echo $pro;
    done;
}

##----------------------------------------------------------------------------##
# init
org-init(){
    [ -z "$PRO" ] && { echo 'project name required'; exit 1; }
    PRO_DATE=$(date +"%D")
    mkdir -p $PRO;

    for subdir in ${ORG_PRO_DIRS//:/ }; do
        mkdir -p "$PRO/$subdir";
    done

    PRO_FILE=$PRO/$PRO$ORG_PRO_SUF; # create *-project.org at top-level
    if [ ! -e $PRO_FILE ]; then
        echo "$ORG_PRO_TPL" | while read -r line ; do
            while [[ "$line" =~ (\$\{[a-zA-Z_][a-zA-Z_0-9]*\}) ]] ; do
                LHS=${BASH_REMATCH[1]}
                RHS="$(eval echo "\"$LHS\"")"
                line=${line//$LHS/$RHS}
            done
            echo "$line" >> $PRO_FILE
        done
    fi;

    echo "Created project [$PRO]";
}

##----------------------------------------------------------------------------##
# init workpack
org-init-workpack(){
    WPK=$PRO
    [ -z "$WPK" ] && { echo 'workpack name required'; exit 1; }
    get-current-project

    WPK_DATE=$(date +"%D")
    mkdir -p $WPK;

    for subdir in ${ORG_WPK_DIRS//:/ }; do
        mkdir -p "$WPK/$subdir";
    done

    WPK_FILE=$WPK/$WPK$ORG_WPK_SUF; # create *-workpack.org at top-level
    if [ ! -e $WPK_FILE ]; then
        echo "$ORG_WPK_TPL" | while read -r line ; do
            while [[ "$line" =~ (\$\{[a-zA-Z_][a-zA-Z_0-9]*\}) ]] ; do
                LHS=${BASH_REMATCH[1]}
                RHS="$(eval echo "\"$LHS\"")"
                line=${line//$LHS/$RHS}
            done
            echo "$line" >> $WPK_FILE
        done
    fi;

    echo "Created workpack [$WPK] in project [$PRO]";
}

# check if current dir is project
get-current-project(){
    ls *$ORG_PRO_SUF &>/dev/null || { echo "not inside a project"; exit 1; }
    PROS=( *$ORG_PRO_SUF )
    PRO=$(basename ${PROS[0]} $ORG_PRO_SUF)
}

##----------------------------------------------------------------------------##
# aliases - convenient for placing them in bashrc...
org-alias(){
    echo "## org-anize
alias oi='org-anize init'     # create new org-project
alias of='org-anize list'     # find and list favorite projects
alias ol='org-anize list -a'  # find and list all projects
alias ob='org-anize browse'   # open projects root dir
alias oe='org-anize edit'     # edit projects org file
od(){cd \$(org-anize dir \$@)}  # change to project dir (needs to be function)"
}

##----------------------------------------------------------------------------##
org-help(){
    echo 'Usage: org-anize <command> [options] [project/pattern]

  init    initialize new project with default directory structure at <project>
  list    find and list available projects
  chdir   change into <project-pattern> directory
  edit    edit <project-pattern>-project.org file with default editor ['$ORG_EDITOR']
  browse  open <project-pattern> directory in default file manager ['$ORG_FILEMANAGER']
  alias   print suggested shell aliases

   -a     work with all projects, default is to work only with favorites
   -V     show script version
   -h     show this help
'
}


##----------------------------------------------------------------------------##

# Require args
[ $# -eq 0 ] && { org-help && exit 0; }

# Execute getopt
ARGS=`getopt --name "SCRIPT" \
    --options "ahV" \
    -- "$@"`
[ $? -ne 0 ] && exit 1; # Exit if bad args
eval set -- "$ARGS" # A little magic

# Now go through all the options
while true; do
    case "$1" in
        # -c|--code-projects)
        #     [ ! -n "$2" ] && (echo "$1: value required" 1>&2 && exit 1);
        #     CODE=$2
        #     shift 2;;
        -a) OPT_ALL=1; shift;;
	-h) org-help && exit 0;;
        -V) grep -m1 'Version' "$0" | sed 's/.*Version.\s*//'; exit 0;;
        --) shift; break;;
        *) echo "$1: Unknown option" 1>&2 && exit 1;;
  esac
done

CMD=${1:-"help"}
PRO=$2;
WPK=$3;

shift;
shift;
shift;

org-$CMD $@;
